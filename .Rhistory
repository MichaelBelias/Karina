View(a)
a= matrix(ncol = dim(KarinaDS)[2], nrow = 2, dimnames = list(names(KarinaDS),c("Missing Percentage","Levels of variable")) )
a= matrix(ncol = dim(KarinaDS)[2], nrow = 2, dimnames = list(c("Missing Percentage","Levels of variable"),names(KarinaDS)) )
for(i in 1:dim(KarinaDS)[2]){
a[1,i]=sum(is.na(KarinaDS[,i]))*100/length(KarinaDS[,i])
a[2,i]= length(unique(KarinaDS[,i]))
}
View(a)
a= matrix(ncol = dim(KarinaDS)[2], nrow = 2, dimnames = list(c("Missing Percentage","Levels of variable"),names(KarinaDS)) )
for(i in 1:dim(KarinaDS)[2]){
a[1,i]=paste(round(sum(is.na(KarinaDS[,i]))*100/length(KarinaDS[,i]),2), "%",sep="")
a[2,i]= length(unique(KarinaDS[,i]))
}
View(a)
table(KarinaDS$Age_binair)
unique(KarinaDS[,i]
)
unique(KarinaDS[,i], incomparables = T)
!is.na(unique(KarinaDS[,i]))
length(!is.na(unique(KarinaDS[,i])))
length(!is.na(unique(KarinaDS[,i]))==T)
length(which(!is.na(unique(KarinaDS[,i]))))
a= matrix(ncol = dim(KarinaDS)[2], nrow = 2,
dimnames = list(c("Missing Percentage","Levels of variable"),names(KarinaDS)) )
for(i in 1:dim(KarinaDS)[2]){
a[1,i]=paste(round(sum(is.na(KarinaDS[,i]))*100/length(KarinaDS[,i]),2), "%",sep="")
a[2,i]= length(which(!is.na(unique(KarinaDS[,i]))))
}
View(a)
View(KarinaDS)
which(a[2,]<10)
a[2,]<10
View(a)
which(as.integer(a[2,])<10)
names(which(a[2,]<10))
names(which(as.integer(a[2,])<10))
names(a[,which(as.integer(a[2,])<10)])
names(a[which(as.integer(a[2,])<10)])
names(a)
a= matrix(ncol = dim(KarinaDS)[2], nrow = 2,
dimnames = list(c("Missing Percentage","Levels of variable"),names(KarinaDS)) )
for(i in 1:dim(KarinaDS)[2]){
a[1,i]=paste(round(sum(is.na(KarinaDS[,i]))*100/length(KarinaDS[,i]),2), "%",sep="")
a[2,i]= length(which(!is.na(unique(KarinaDS[,i]))))
}
names(a)
View(a)
col.names(a)
colnames(a)
colnames(which(as.integer(a[2,])<10))
colnames()[which(as.integer(a[2,])<10)]
colnames()[which(as.integer(a[2,])<10),]
colnames(a)[which(as.integer(a[2,])<10),]
colnames(a)[which(as.integer(a[2,])<10)]
for(i in colnames(a)[which(as.integer(a[2,])<10)] ){
assign(paste("Plot", k,sep="") , eval(parse(text=paste("ggplot() +  geom_bar(aes(y = ..count..,
x = as.factor(" i ")),colour=""red"", fill=""blue"",data=KarinaDS") )))
}
for(i in colnames(a)[which(as.integer(a[2,])<10)] ){
assign(paste("Plot", k,sep="") , eval(parse(text=paste("ggplot() +  geom_bar(aes(y = ..count..,
x = as.factor(", i ,")),colour=""red"", fill=""blue"",data=KarinaDS") )))
}
for(i in colnames(a)[which(as.integer(a[2,])<10)] ){
assign(paste("Plot", k,sep="") , eval(parse(text=paste("ggplot() +  geom_bar(aes(y = ..count..,
x = as.factor(", i ,")),colour='red', fill='blue',data=KarinaDS") )))
}
paste("ggplot() +  geom_bar(aes(y = ..count..,
x = as.factor(", i ,")),colour='red', fill='blue',data=KarinaDS")
paste("ggplot() +  geom_bar(aes(y = ..count..,x = as.factor(", i ,")),colour='red', fill='blue',data=KarinaDS") )
paste("ggplot() +  geom_bar(aes(y = ..count..,x = as.factor(", i ,")),colour='red', fill='blue',data=KarinaDS")
for(i in colnames(a)[which(as.integer(a[2,])<10)] ){
assign(paste("Plot", k,sep="") , eval(parse(text=paste("ggplot() +  geom_bar(aes(y = ..count..,x = as.factor(", i ,")),colour='red', fill='blue',data=KarinaDS") )))
}
for(i in colnames(a)[which(as.integer(a[2,])<10)] ){
assign(paste("Plot", k,sep="") , eval(parse(text=paste("ggplot() +  geom_bar(aes(y = ..count..,x = as.factor(", i ,")),colour=red, fill=blue,data=KarinaDS") )))
}
for(i in colnames(a)[which(as.integer(a[2,])<10)] ){
assign(paste("Plot", k,sep="") , eval(parse(text=paste("ggplot() +  geom_bar(aes(y = ..count..,x = as.factor(", i ,")),
colour=red, fill=blue,data=KarinaDS") )))
}
library(foreign)
library(haven)
library(mice)
library(VIM)
library(ggplot2)
library(nnet)
library(foreign)
library(haven)
library(mice)
library(VIM)
library(ggplot2)
library(nnet)
library(foreign)
library(haven)
library(mice)
library(VIM)
library(ggplot2)
library(nnet)
KarinaDS <- read_sav("C:/Users/z047185/Desktop/Karina/Karina/NEW3 - exclusie - inclusief 2 pt GRainne 09122016.sav", user_na = F)
KarinaDS <- as.data.frame(KarinaDS)
ggplot() +  geom_bar(aes(y = ..count..,x = as.factor(No_study)),colour="red", fill="blue",data=KarinaDS)
ggplot() +  geom_bar(aes(y = ..count..,x = as.factor(Age_binair)),colour="red", fill="blue",data=KarinaDS)
ggplot() +  geom_bar(aes(y = ..count..,x = as.factor(Gender)),colour="red", fill="blue",data=KarinaDS)
.libPaths()
install.packages("ggplot2", lib = "C:/Program Files/R/R-3.3.2/library")
install.packages("ggplot2", lib = "C:/Program Files/R/R-3.3.2/library")
install.packages("ggplot2", lib = "C:/Program Files/R/R-3.3.2/library")
library(foreign, lib.loc = "c:/Program Files/R/R-3.3.2/library/")
library(haven,lib.loc = "c:/Program Files/R/R-3.3.2/library/")
library(mice,lib.loc = "c:/Program Files/R/R-3.3.2/library/")
library(VIM,lib.loc = "c:/Program Files/R/R-3.3.2/library/")
library(ggplot2,lib.loc = "c:/Program Files/R/R-3.3.2/library/")
library(nnet,lib.loc = "c:/Program Files/R/R-3.3.2/library/")
library(lme4)
library(npmlt)
library(foreign)
library(haven)
library(mice)
library(VIM)
library(ggplot2)
library(nnet)
library(lme4)
library(npmlt)
library(foreign)
library(haven)
library(mice)
library(VIM)
library(ggplot2)
library(nnet)
library(lme4)
library(npmlt)
install.packages("npmlt")
KarinaDS <- read_sav("C:/Users/z047185/Desktop/Karina/NEW3 - exclusie - inclusief 2 pt GRainne 09122016.sav", user_na = F)
KarinaDS <- as.data.frame(KarinaDS)
KarinaDS <- read_sav("NEW3 - exclusie - inclusief 2 pt GRainne 09122016.sav", user_na = F)
KarinaDS <- as.data.frame(KarinaDS)
ggplot() +  ggtitle('Barplot of Number of Studies') +
geom_bar(aes(y = ..count..,x = as.factor(No_study)),colour="red", fill="darkgreen",data=KarinaDS) +theme_light()
k=1
for(i in colnames(a)[which(as.integer(a[2,])<10)] ){
assign(paste("Plot", k,sep="") , eval(parse(text=paste("ggplot() +ggtitle('Barplot of",i," ') +   geom_bar(aes(y = ..count..,x = as.factor(", i ,")),colour='red', fill='darkgreen',data=KarinaDS) +theme_light()") )))
k=k+1
}
a= matrix(ncol = dim(KarinaDS)[2], nrow = 2,
dimnames = list(c("Missing Percentage","Levels of variable"),names(KarinaDS)) )
for(i in 1:dim(KarinaDS)[2]){
a[1,i]=paste(round(sum(is.na(KarinaDS[,i]))*100/length(KarinaDS[,i]),2), "%",sep="")
a[2,i]= length(which(!is.na(unique(KarinaDS[,i]))))
}
View(a)
k=1
for(i in colnames(a)[which(as.integer(a[2,])<10)] ){
assign(paste("Plot", k,sep="") , eval(parse(text=paste("ggplot() +ggtitle('Barplot of",i," ') +   geom_bar(aes(y = ..count..,x = as.factor(", i ,")),colour='red', fill='darkgreen',data=KarinaDS) +theme_light()") )))
k=k+1
}
multiplot(Plot1, Plot2, Plot3, Plot4, cols=2)
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
multiplot(Plot1, Plot2, Plot3, Plot4, cols=2)
multiplot(Plot5, Plot6, Plot7, Plot8, cols=2)
for(i in colnames(a)[which(as.integer(1<a[2,])<10)] ){
assign(paste("Plot", k,sep="") , eval(parse(text=paste("ggplot() +ggtitle('Barplot of",i," ') +   geom_bar(aes(y = ..count..,x = as.factor(", i ,")),colour='red', fill='darkgreen',data=KarinaDS) +theme_light()") )))
k=k+1
}
KarinaDS <- read_sav("NEW3 - exclusie - inclusief 2 pt GRainne 09122016.sav", user_na = F)
KarinaDS <- as.data.frame(KarinaDS)
a= matrix(ncol = dim(KarinaDS)[2], nrow = 2,
dimnames = list(c("Missing Percentage","Levels of variable"),names(KarinaDS)) )
for(i in 1:dim(KarinaDS)[2]){
a[1,i]=paste(round(sum(is.na(KarinaDS[,i]))*100/length(KarinaDS[,i]),2), "%",sep="")
a[2,i]= length(which(!is.na(unique(KarinaDS[,i]))))
}
k=1
for(i in colnames(a)[which(as.integer(a[2,])<10)] ){
assign(paste("Plot", k,sep="") , eval(parse(text=paste("ggplot() +ggtitle('Barplot of",i," ') +   geom_bar(aes(y = ..count..,x = as.factor(", i ,")),colour='red', fill='darkgreen',data=KarinaDS) +theme_light()") )))
k=k+1
}
multiplot(Plot37, Plot38, Plot39, Plot40, cols=2)
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
multiplot(Plot1, Plot2, Plot3, Plot4, cols=2)
a[1,][a[1,] =="0%"]
View(KarinaDS)
KarinaDS <- read_sav("NEW3 - exclusie - inclusief 2 pt GRainne 09122016.sav", user_na = F)
KarinaDS <- as.data.frame(KarinaDS)
a= matrix(ncol = dim(KarinaDS)[2], nrow = 2,
dimnames = list(c("Missing Percentage","Levels of variable"),names(KarinaDS)) )
for(i in 1:dim(KarinaDS)[2]){
a[1,i]=paste(round(sum(is.na(KarinaDS[,i]))*100/length(KarinaDS[,i]),2), "%",sep="")
a[2,i]= length(which(!is.na(unique(KarinaDS[,i]))))
}
for(i in 1:dim(KarinaDS)[2]){
a[1,i]=paste(round(sum(is.na(KarinaDS[,i]))*100/length(KarinaDS[,i]),2), "%",sep="")
a[2,i]= length(which(!is.na(unique(KarinaDS[,i]))))
};rm(i)
k=1
for(i in colnames(a)[which(as.integer(a[2,])<10)] ){
assign(paste("Plot", k,sep="") , eval(parse(text=paste("ggplot() +ggtitle('Barplot of",i," ') +   geom_bar(aes(y = ..count..,x = as.factor(", i ,")),colour='red', fill='darkgreen',stat='identity',data=KarinaDS)+ coord_polar('y', start=0) +theme_light()") )))
k=k+1
}
Plot1
k=1
for(i in colnames(a)[which(as.integer(a[2,])<10)] ){
assign(paste("Plot", k,sep="") , eval(parse(text=paste("ggplot() +ggtitle('Barplot of",i," ') +   geom_bar(aes(y = ..count..,x = as.factor(", i ,")),colour='red', fill='darkgreen',data=KarinaDS) +theme_light()") )))
k=k+1
}
multiplot(Plot1, Plot2, Plot3, Plot4, cols=3)
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
library(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
multiplot(Plot1, Plot2, Plot3, Plot4, cols=3)
rm(list=ls())
library(rstan)
model <- "
// One-Sample Order Restricted Comparsion of Means
data {
int<lower=0> ndata;
vector[ndata] x;
}
parameters {
real sigmatmp;
real<upper=0> delta;
}
transformed parameters {
real<lower=0> sigma;
real mu;
sigma <- fabs(sigmatmp);
mu <- delta * sigma;
}
model {
// Delta and sigma Come From (Half) Cauchy Distributions
sigmatmp ~ cauchy(0, 1);
delta ~ cauchy(0, 1)T[,0];
// Data
x ~ normal(mu, sigma);
}"
# Read data Dr. Smith
Winter <- c(-0.05,0.41,0.17,-0.13,0.00,-0.05,0.00,0.17,0.29,0.04,0.21,0.08,0.37,
0.17,0.08,-0.04,-0.04,0.04,-0.13,-0.12,0.04,0.21,0.17,0.17,0.17,
0.33,0.04,0.04,0.04,0.00,0.21,0.13,0.25,-0.05,0.29,0.42,-0.05,0.12,
0.04,0.25,0.12)
Summer <- c(0.00,0.38,-0.12,0.12,0.25,0.12,0.13,0.37,0.00,0.50,0.00,0.00,-0.13,
-0.37,-0.25,-0.12,0.50,0.25,0.13,0.25,0.25,0.38,0.25,0.12,0.00,0.00,
0.00,0.00,0.25,0.13,-0.25,-0.38,-0.13,-0.25,0.00,0.00,-0.12,0.25,
0.00,0.50,0.00)
x <- Winter - Summer  # allowed because it is a within-subjects design
x <- x / sd(x)        # standardize
ndata <- length(Winter)  # number of subjects
data <- list(x=x, ndata=ndata)  # to be passed on to Stan
myinits <- list(
list(delta=-abs(rnorm(1,0,1)), deltaprior=-abs(rnorm(1,0,1)), sigmatmp=.1),
list(delta=-abs(rnorm(1,0,1)), deltaprior=-abs(rnorm(1,0,1)), sigmatmp=.2),
list(delta=-abs(rnorm(1,0,1)), deltaprior=-abs(rnorm(1,0,1)), sigmatmp=.3))
parameters <- c("delta")
# The following command calls Stan with specific options.
# For a detailed description type "?rstan".
samples <- stan(model_code=model,
data=data,
init=myinits,  # If not specified, gives random inits
pars=parameters,
iter=30000,
chains=3,
thin=1,
# warmup=100,  # Stands for burn-in; Default = iter/2
seed=123  # Setting seed; Default is random seed
)
library(shinystan)
library(shinystan)
launch_shinystan(samples)
plot(samples)
delta.posterior <- extract(samples)$delta
library(polspline) # this package can be installed from within R
fit.posterior <- logspline(delta.posterior)
fit.posterior <- logspline(delta.posterior,ubound=0) # NB. note the bound
x0 <- qlogspline(0.025,fit.posterior)
x1 <- qlogspline(0.975,fit.posterior)
posterior <- dlogspline(0, fit.posterior) # this gives the pdf at point delta = 0
prior     <- 2*dcauchy(0)       # height of order--restricted prior at delta = 0
BF01      <- posterior/prior
BF01
par(cex.main = 1.5, mar = c(5, 6, 4, 5) + 0.1, mgp = c(3.5, 1, 0), cex.lab = 1.5,
font.lab = 2, cex.axis = 1.3, bty = "n", las=1)
xlow  <- -3
xhigh <- 0
yhigh <- 12
Nbreaks <- 80
y       <- hist(delta.posterior, Nbreaks, plot=F)
plot(c(y$breaks, max(y$breaks)), c(0,y$density,0), type="S", lwd=2, lty=2,
xlim=c(xlow,xhigh), ylim=c(0,yhigh), xlab=" ", ylab="Density", axes=F)
axis(1, at = c(-3,-2,-1,0), lab=c("-3","-2","-1","0"))
axis(2)
mtext(expression(delta), side=1, line = 2.8, cex=2)
par(new=T)
plot(fit.posterior, ylim=c(0,yhigh), xlim=c(xlow,xhigh), lty=1, lwd=1, axes=F)
points(0, dlogspline(0, fit.posterior),pch=19, cex=2)
par(new=T)
plot ( function( x ) 2*dcauchy( x, 0, 1 ), xlow, xhigh, ylim=c(0,yhigh),
xlim=c(xlow,xhigh), lwd=2, lty=1, ylab=" ", xlab = " ", axes=F)
axis(1, at = c(-3,-2,-1,0), lab=c("-3","-2","-1","0"))
axis(2)
points(0, 2*dcauchy(0), pch=19, cex=2)
# The following command calls Stan with specific options.
# For a detailed description type "?rstan".
samples <- stan(model_code=model,
data=data,
init=myinits,  # If not specified, gives random inits
pars=parameters,
iter=30000,
chains=3,
thin=1,
warmup=100,  # Stands for burn-in; Default = iter/2
seed=123  # Setting seed; Default is random seed
)
launch_shinystan(samples)
# clears workspace:
rm(list=ls())
library(rstan)
model <- "
// Cheating Latent Mixture Model
data {
int<lower=1> n;
int<lower=1> p;
int<lower=1,upper=n> k[p];
int<lower=0,upper=1> truth[p];
}
parameters {
real<lower=0,upper=1> phi;
real<lower=0,upper=1> mubon;
real<lower=0> mudiff;
real<lower=5,upper=50> lambdabon;
real<lower=5,upper=50> lambdache;
vector<lower=0,upper=1>[p] theta;
}
transformed parameters {
vector[2] lp_parts[p];
vector<lower=0>[2] alpha;
vector<lower=0>[2] beta;
real<lower=0,upper=1> muche;
// Additivity on Logit Scale
muche <- inv_logit(logit(mubon) + mudiff);
// Transformation to Group Mean and Precision
alpha[1] <- mubon * lambdabon;
beta[1] <- lambdabon * (1 - mubon);
alpha[2] <- muche * lambdache;
beta[2]  <- lambdache * (1 - muche);
// Data are Binomial with Rate Given by
// Each Person’s Group Assignment
for (i in 1:p) {
lp_parts[i,1] <- log1m(phi) + beta_log(theta[i], alpha[1], beta[1]);
lp_parts[i,2] <- log(phi) + beta_log(theta[i], alpha[2], beta[2]);
}
}
model {
// Priors
mubon ~ beta(1, 1);  // can be removed
mudiff ~ normal(0, 1 / sqrt(.5))T[0,];  // Constrained to be Positive
// Relatively Uninformative Prior on Base Rate
phi ~ beta(5, 5);
for (i in 1:p)
increment_log_prob(log_sum_exp(lp_parts[i]));
k ~ binomial(n, theta);
}
generated quantities {
int<lower=0,upper=1> z[p];
real pc;
vector[p] pct;
for (i in 1:p) {
vector[2] prob;
prob <- softmax(lp_parts[i]);
// Each Person Belongs to One of Two Latent Groups
z[i] <- bernoulli_rng(prob[2]);
// Correct Count
pct[i] <- if_else(z[i] == truth[i], 1, 0);
}
pc <- sum(pct);
}"
cheat.dat  <- read.table("cheat.csv", header=F, sep=",")
cheatt.dat <- read.table("cheatt.csv", header=F, sep="")
truth <- cheatt.dat$V1  # truth = 1 if cheater
k <- apply(cheat.dat, 1, sum)  # total correct per participant
p <- length(k)  # number of people
n <- 40         # total trials
data <- list(p=p, k=k, n=n, truth=truth) # To be passed on to Stan
myinits <- list(
list(mudiff=.1, phi=.5, mubon=.5, lambdabon=30, lambdache=25,
theta=rep(.5, p)),
list(mudiff=.15, phi=.5, mubon=.5, lambdabon=25, lambdache=30,
theta=rep(.5, p)))
# Parameters to be monitored:
parameters <- c("theta", "z", "mubon", "lambdabon", "muche", "lambdache",
"mudiff", "phi", "alpha", "beta", "pc")
# The following command calls Stan with specific options.
# For a detailed description type "?rstan".
samples <- stan(model_code=model,
data=data,
init=myinits,  # If not specified, gives random inits
pars=parameters,
iter=1000,
chains=2,
thin=1,
warmup = 200,  # Stands for burn-in; Default = iter/2
# seed = 123  # Setting seed; Default is random seed
)
cheat.dat  <- read.table("cheat.csv", header=F, sep=",")
cheatt.dat <- read.table("cheatt.csv", header=F, sep="")
